<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>
    <script>
        // function sayName(name) {
        //     alert(name);
        // }

        // function sum(num1, num2) {
        //     return num1 + num2;
        // }

        // function sayHi() {
        //     alert("hi");
        // }
        // //返回的是函数希望接受的参数的个数
        // alert(sayName.length);      //1
        // alert(sum.length);          //2
        // alert(sayHi.length);        //0

        //method.apply(context, [arguments]);
        function sum(a,b){
            return a+b;
        }
        function callsum1(a,b){
            //第一个参数传入sum的作用域，第二个参数传函数的参数数组（当然传arguments也是可以的）
            return sum.apply(this,arguments);
        }
        function callsum2(a,b){
            return sum.apply(this,[a,b]);
        }
        console.log(callsum1(10,20));
        console.log(callsum2(10,20));

        // method.call(context, arguments);
        //call方法与apply基本相同，唯一区别在于要把参数数组元素一一列举出来

        /*扩展作用域*/
        window.color = "red";
        var o = {color:"blue"};

        function sayColor(){
            console.log(this.color);
        }
        sayColor();//red
        sayColor.apply(this);//red
        sayColor.apply(o);//blue
        //此时apply更改了函数的作用域，让其内部的this指向更改到了对象o上
        //好处，降低耦合

        //bind

        window.color = "red";
        var o = {color:"blue"};

        function sayColor(){
            console.log(this.color);
        }

        var newsayColor = sayColor.bind(o);
        newsayColor();//blue
        //绑定作用域后，即便是在全局环境调用方法，this指向依旧会更改
        
        //tostring(),toLocalString(),valueof()都会返回函数的代码

    </script>
</body>

</html>